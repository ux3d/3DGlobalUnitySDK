// #pragma target 4.0
#pragma kernel FXAA

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Builtin/BuiltinData.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/PostProcessDefines.hlsl"

// #define SMAA_RT_METRICS float4(1.0 / 1980.0, 1.0 / 1080.0, 1980.0, 1080.0)
// #define SMAA_HLSL_4
// #define SMAA_PRESET_HIGH
// #include "SMAA.hlsl"

RWTexture2D<float4> _OutputTexture;
Texture2D _colorMosaic;
SamplerState sampler_colorMosaic;

#define FXAA_SPAN_MAX       (4.0)
#define FXAA_REDUCE_MUL     (1.0 / 4.0)
#define FXAA_REDUCE_MIN     (1.0 / 32.0)
// original:
// #define FXAA_SPAN_MAX       (8.0)
// #define FXAA_REDUCE_MUL     (1.0 / 8.0)
// #define FXAA_REDUCE_MIN     (1.0 / 128.0)

float LuminanceGamma(float3 c) {
    float3 w = float3(0.299, 0.587, 0.114);
    return sqrt(dot(c, w));
}

float3 Fetch(TEXTURE2D_PARAM(_InputTexture, _InputTextureSampler), float2 coords, float2 offset)
{
    float2 uv = saturate(coords + offset) * _RTHandlePostProcessScale.xy;
    float3 color = SAMPLE_TEXTURE2D_LOD(_InputTexture, _InputTextureSampler, uv, 0.0).xyz;
    return saturate(color);
}

float4 Load(TEXTURE2D(_InputTexture), int2 icoords, int idx, int idy)
{
    return LOAD_TEXTURE2D(_InputTexture, min(icoords + int2(idx, idy), _PostProcessScreenSize.xy - 1.0));
}

float FetchAlpha(TEXTURE2D_PARAM(_InputTexture, _InputTextureSampler), float2 coords, float2 offset)
{
    float2 uv = saturate(coords + offset) * _RTHandleScale.xy;
    return SAMPLE_TEXTURE2D_LOD(_InputTexture, _InputTextureSampler, uv, 0.0).w;
}

SamplerState PointSampler2 { Filter = MIN_MAG_MIP_POINT; AddressU = Clamp; AddressV = Clamp; };

void RunFXAA(TEXTURE2D_PARAM(_InputTexture, _InputTextureSampler), inout float4 outColor, uint2 positionSS, float2 positionNDC)
{
    float c = LuminanceGamma(Load(_InputTexture, positionSS, 0, 0).rgb);
    float u = LuminanceGamma(Load(_InputTexture, positionSS, 0, -1).rgb);
    float d = LuminanceGamma(Load(_InputTexture, positionSS, 0, 1).rgb);
    float l = LuminanceGamma(Load(_InputTexture, positionSS, -1, 0).rgb);
    float r = LuminanceGamma(Load(_InputTexture, positionSS, 1, 0).rgb);

    // ----

    float3 rgbM = Load(_InputTexture, positionSS, 0, 0).rgb;
    float3 rgbNW = Load(_InputTexture, positionSS, -1, -1).rgb;
    float3 rgbNE = Load(_InputTexture, positionSS, 1, -1).rgb;
    float3 rgbSW = Load(_InputTexture, positionSS, -1, 1).rgb;
    float3 rgbSE = Load(_InputTexture, positionSS, 1, 1).rgb;

    float lumaM = LuminanceGamma(rgbM);
    float lumaNW = LuminanceGamma(rgbNW);
    float lumaNE = LuminanceGamma(rgbNE);
    float lumaSW = LuminanceGamma(rgbSW);
    float lumaSE = LuminanceGamma(rgbSE);

    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));
    float edge = 4.0 * lumaM - lumaNW - lumaNE - lumaSW - lumaSE;

    // ----

    // if (lumaMax - lumaMin < 0.05) {
    //     return;
    // }
    if (edge < 0.05) {
        return;
    }

    // outColor.rgb = float3(1.0, 0.0, 0.0);
    // outColor.rgb = (rgbM + rgbNW + rgbNE + rgbSW + rgbSE) / 5.0;

    outColor.rgb =
        0.2 * rgbM
        + 0.2 * rgbNW
        + 0.2 * rgbNE
        + 0.2 * rgbSW
        + 0.2 * rgbSE;

    // outColor.rgb =
    //     0.5 * rgbM
    //     + 0.125 * rgbNW
    //     + 0.125 * rgbNE
    //     + 0.125 * rgbSW
    //     + 0.125 * rgbSE;

    float3 colors[9] = {
        Load(_InputTexture, positionSS, -1, -1).rgb,
        Load(_InputTexture, positionSS, 0, -1).rgb,
        Load(_InputTexture, positionSS, 1, -1).rgb,
        Load(_InputTexture, positionSS, -1, 0).rgb,
        Load(_InputTexture, positionSS, 0, 0).rgb,
        Load(_InputTexture, positionSS, 1, 0).rgb,
        Load(_InputTexture, positionSS, -1, 1).rgb,
        Load(_InputTexture, positionSS, 0, 1).rgb,
        Load(_InputTexture, positionSS, 1, 1).rgb
    };

    float coeffs[9] = {
        1.0 / 16.0,
        1.0 / 8.0,
        1.0 / 16.0,
        1.0 / 8.0,
        1.0 / 4.0,
        1.0 / 8.0,
        1.0 / 16.0,
        1.0 / 8.0,
        1.0 / 16.0
    };

    float3 conv = 0.0.xxx;
    for (uint i = 0; i < 9; i++) {
        conv += coeffs[i] * colors[i];
    }

    outColor.rgb = conv;

    // outColor.r = 1.0;
    return;

    // float convolution = 4 * c - u - d - l - r;
    // float convolution = lumaMax - lumaMin;
    // outColor.rgb = float3(convolution, convolution, convolution);


    float2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * 0.25 * 0.5, 0.001);
    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);

    dir = min((FXAA_SPAN_MAX).xx, max((-FXAA_SPAN_MAX).xx, dir * rcpDirMin)) * _ScreenSize.zw;

    float3 rgb03 = Fetch(TEXTURE2D_ARGS(_InputTexture, _InputTextureSampler), positionNDC, dir * (-1.0 / 3.0 - 0.5));
    float3 rgb13 = Fetch(TEXTURE2D_ARGS(_InputTexture, _InputTextureSampler), positionNDC, dir * (1.0 / 3.0 - 0.5));
    float3 rgb23 = Fetch(TEXTURE2D_ARGS(_InputTexture, _InputTextureSampler), positionNDC, dir * (2.0 / 3.0 - 0.5));
    float3 rgb33 = Fetch(TEXTURE2D_ARGS(_InputTexture, _InputTextureSampler), positionNDC, dir * (4.0 / 3.0 - 0.5));

    float3 rgbA = 0.5 * (rgb13 + rgb23);
    float3 rgbB = rgbA * 0.5 + 0.25 * (rgb03 + rgb33);

    float lumaB = LuminanceGamma(rgbB);

    if ((lumaB < lumaMin) || (lumaB > lumaMax)) {
        outColor.rgb = rgbA;
    }
    else {
        outColor.rgb = rgbB;
    }
}


[numthreads(1, 1, 1)]
void FXAA(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);
    uint2 positionSS = dispatchThreadId.xy;
    float2 positionNDC = positionSS * _PostProcessScreenSize.zw + (0.5 * _PostProcessScreenSize.zw);

    float4 outColor = _colorMosaic.Load(float4(positionSS, 0, 0));

    if (4 * positionSS.x % int(_PostProcessScreenSize.x) == 0 || 4 * positionSS.y % int(_PostProcessScreenSize.y) == 0) {
        // do not run fxx on debug view boundaries
        // outColor = float4(1.0, 0.0, 1.0, 1.0);
    }
    else {
        RunFXAA(_colorMosaic, s_linear_clamp_sampler, outColor, positionSS, positionNDC);
    }

    _OutputTexture[positionSS] = outColor;
}
